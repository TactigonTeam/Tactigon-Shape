{"version":3,"file":"blockly_field_dependent_dropdown.js","mappings":"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","sources":["webpack://@blockly/field-dependent-dropdown/webpack/universalModuleDefinition","webpack://@blockly/field-dependent-dropdown/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/field-dependent-dropdown/webpack/bootstrap","webpack://@blockly/field-dependent-dropdown/webpack/runtime/define property getters","webpack://@blockly/field-dependent-dropdown/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/field-dependent-dropdown/webpack/runtime/make namespace object","webpack://@blockly/field-dependent-dropdown/./src/dependent_dropdown_options_change.ts","webpack://@blockly/field-dependent-dropdown/./src/field_dependent_dropdown.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\n/**\r\n * @fileoverview An event representing when a dependent dropdown field changes\r\n * state.\r\n */\r\n\r\nimport * as Blockly from 'blockly/core';\r\nimport type {FieldDependentDropdown} from './field_dependent_dropdown';\r\n\r\n/**\r\n * A deep equality comparison between the two provided arrays recursively\r\n * comparing any child elements that are also arrays.\r\n *\r\n * @param a The first array to compare.\r\n * @param b The second array to compare.\r\n * @returns Whether the arrays are deeply equivalent.\r\n */\r\nfunction arraysAreEquivalent<T>(a: T[], b: T[]): boolean {\r\n  return (\r\n    a.length === b.length &&\r\n    a.every((aElement, index) => {\r\n      const bElement = b[index];\r\n      if (Array.isArray(aElement) && Array.isArray(bElement)) {\r\n        return arraysAreEquivalent(aElement, bElement);\r\n      }\r\n      return aElement === bElement;\r\n    })\r\n  );\r\n}\r\n\r\n/** The structure of a serialized DependentDropdownOptionsChange. */\r\nexport interface DependentDropdownOptionsChangeJson\r\n  extends Blockly.Events.BlockBaseJson {\r\n  name: string;\r\n  newValue: string;\r\n  oldValue: string;\r\n  oldOptions: Blockly.MenuOption[];\r\n  newOptions: Blockly.MenuOption[];\r\n}\r\n\r\n/**\r\n * A change event representing a simultaneous change to a dropdown field's\r\n * options and value. The old value must be one of the old options, and the new\r\n * value must be one of the new options. Unlike a normal value change event,\r\n * it's possible for this event to change the value to something that wasn't\r\n * previously one of the valid options--in either direction--by also changing\r\n * the options at the same time.\r\n */\r\nexport class DependentDropdownOptionsChange extends Blockly.Events.BlockBase {\r\n  /** The name to register with Blockly for the type of event. */\r\n  // eslint-disable-next-line @typescript-eslint/naming-convention\r\n  static readonly EVENT_TYPE: string = 'dropdown_options_change';\r\n\r\n  /** The name of the change event type for registering with Blockly. */\r\n  readonly type = DependentDropdownOptionsChange.EVENT_TYPE;\r\n\r\n  /** The name of the field that changed. */\r\n  name?: string;\r\n\r\n  /** The original value of the field. */\r\n  oldValue?: string;\r\n\r\n  /** The new value of the field. */\r\n  newValue?: string;\r\n\r\n  /** The original available options for the dropdown field. */\r\n  oldOptions?: Blockly.MenuOption[];\r\n\r\n  /** The new available options for the dropdown field. */\r\n  newOptions?: Blockly.MenuOption[];\r\n\r\n  /**\r\n   * Construct a new DependentDropdownOptionsChange.\r\n   *\r\n   * @param block The changed block. Undefined for a blank event.\r\n   * @param name Name of the field affected.\r\n   * @param oldValue Previous value of field.\r\n   * @param newValue New value of field.\r\n   * @param oldOptions Previous options for the dropdown.\r\n   * @param newOptions New options for the dropdown.\r\n   */\r\n  constructor(\r\n    block?: Blockly.Block,\r\n    name?: string,\r\n    oldValue?: string,\r\n    newValue?: string,\r\n    oldOptions?: Blockly.MenuOption[],\r\n    newOptions?: Blockly.MenuOption[],\r\n  ) {\r\n    super(block);\r\n\r\n    if (\r\n      !block ||\r\n      !name ||\r\n      !oldValue ||\r\n      !newValue ||\r\n      !oldOptions ||\r\n      !newOptions\r\n    ) {\r\n      // Blank event to be populated by fromJson.\r\n      return;\r\n    }\r\n\r\n    this.name = name;\r\n    this.oldValue = oldValue;\r\n    this.newValue = newValue;\r\n    this.oldOptions = oldOptions;\r\n    this.newOptions = newOptions;\r\n  }\r\n\r\n  /**\r\n   * Encode the event as JSON.\r\n   *\r\n   * @returns JSON representation.\r\n   */\r\n  toJson(): DependentDropdownOptionsChangeJson {\r\n    const json = super.toJson() as DependentDropdownOptionsChangeJson;\r\n    if (\r\n      !this.name ||\r\n      !this.oldValue ||\r\n      !this.newValue ||\r\n      !this.oldOptions ||\r\n      !this.newOptions\r\n    ) {\r\n      throw new Error(\r\n        'The changed element is undefined. Either pass all needed ' +\r\n          'parameters to the constructor, or call fromJson.',\r\n      );\r\n    }\r\n    json['name'] = this.name;\r\n    json['oldValue'] = this.oldValue;\r\n    json['newValue'] = this.newValue;\r\n    json['oldOptions'] = this.oldOptions;\r\n    json['newOptions'] = this.newOptions;\r\n    return json;\r\n  }\r\n\r\n  /**\r\n   * Decode the JSON event.\r\n   *\r\n   * @param json JSON representation.\r\n   * @param workspace\r\n   * @param event\r\n   * @returns The deserialized event.\r\n   */\r\n  static fromJson(\r\n    json: DependentDropdownOptionsChangeJson,\r\n    workspace: Blockly.Workspace,\r\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\r\n    event?: any,\r\n  ): DependentDropdownOptionsChange {\r\n    const newEvent = super.fromJson(\r\n      json,\r\n      workspace,\r\n      event,\r\n    ) as DependentDropdownOptionsChange;\r\n    newEvent.name = json['name'];\r\n    newEvent.oldValue = json['oldValue'];\r\n    newEvent.newValue = json['newValue'];\r\n    newEvent.oldOptions = json['oldOptions'];\r\n    newEvent.newOptions = json['newOptions'];\r\n    return newEvent;\r\n  }\r\n\r\n  /**\r\n   * Does this event leave all state as it was before?\r\n   *\r\n   * @returns False if something changed.\r\n   */\r\n  isNull(): boolean {\r\n    const valuesAreEqual = this.oldValue === this.newValue;\r\n    const optionsAreEquivalent =\r\n      this.oldOptions === this.newOptions ||\r\n      (Array.isArray(this.oldOptions) &&\r\n        Array.isArray(this.newOptions) &&\r\n        arraysAreEquivalent(this.oldOptions, this.newOptions));\r\n    return valuesAreEqual && optionsAreEquivalent;\r\n  }\r\n\r\n  /**\r\n   * Run a change event.\r\n   *\r\n   * @param forward True if run forward, false if run backward (undo).\r\n   */\r\n  run(forward: boolean): void {\r\n    if (\r\n      !this.blockId ||\r\n      !this.name ||\r\n      !this.oldValue ||\r\n      !this.newValue ||\r\n      !this.oldOptions ||\r\n      !this.newOptions\r\n    ) {\r\n      console.warn(\"Can't run uninitialized event.\");\r\n      return;\r\n    }\r\n    const workspace = this.getEventWorkspace_();\r\n    const block = workspace.getBlockById(this.blockId);\r\n    if (!block) {\r\n      console.warn(\"Can't change non-existent block: \" + this.blockId);\r\n      return;\r\n    }\r\n\r\n    const dropdown = block.getField(this.name) as FieldDependentDropdown;\r\n    if (!dropdown) {\r\n      console.warn(\"Can't change non-existent dropdown field: \" + this.name);\r\n      return;\r\n    }\r\n\r\n    const value = forward ? this.newValue : this.oldValue;\r\n    const options = forward ? this.newOptions : this.oldOptions;\r\n\r\n    // Record the options on the dropdown for the option generator to access.\r\n    dropdown.dependencyData.derivedOptions = options;\r\n\r\n    // Re-run the option generator to update the options on the dropdown.\r\n    dropdown.getOptions(false);\r\n\r\n    // Set the value to one of the now-available options.\r\n    dropdown.setValue(value);\r\n  }\r\n}\r\n\r\nBlockly.registry.register(\r\n  Blockly.registry.Type.EVENT,\r\n  DependentDropdownOptionsChange.EVENT_TYPE,\r\n  DependentDropdownOptionsChange,\r\n);\r\n","/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\n/**\r\n * @fileoverview A Blockly dropdown menu field where the options can change\r\n * depending on the value of another field.\r\n */\r\n\r\nimport * as Blockly from 'blockly/core';\r\nimport {DependentDropdownOptionsChange} from './dependent_dropdown_options_change';\r\n\r\n/** The type of the mapping from parent value to child options. */\r\nexport interface ChildOptionMapping {\r\n  [key: string]: Blockly.MenuOption[];\r\n}\r\n\r\n// This type isn't exported from Blockly so we have to derive it from the API.\r\ntype FieldConfig = Exclude<\r\n  ConstructorParameters<typeof Blockly.Field>[2],\r\n  undefined\r\n>;\r\n\r\n/** fromJson config for a dependent dropdown field. */\r\nexport interface FieldDependentDropdownFromJsonConfig extends FieldConfig {\r\n  parentName: string;\r\n  optionMapping: ChildOptionMapping;\r\n  defaultOptions?: Blockly.MenuOption[];\r\n}\r\n\r\n/**\r\n * A structure for managing data needed by the menu generator of a\r\n * FieldDependentDropdown.\r\n */\r\ninterface DependencyData {\r\n  /**\r\n   * A reference to the parent field of an associated dependent dropdown. Absent\r\n   * until the parent field is initialized. This field's value determines the\r\n   * available options of the child field.\r\n   */\r\n  parentField?: Blockly.Field<string>;\r\n\r\n  /**\r\n   * The child field's currently available menu options based on the current\r\n   * value of the parent field. Absent until the parent field is initialized.\r\n   */\r\n  derivedOptions?: Blockly.MenuOption[];\r\n}\r\n\r\n/**\r\n * A dropdown field that automatically updates its own options based on a\r\n * mapping from a parent field's value. The parent field must be attached to the\r\n * block before this child field.\r\n *\r\n * When this field is attached to a block, it will find the parent field and\r\n * attach a validator to the parent field that intercepts changes to its value\r\n * to update the options on this field. If the new validator is later removed\\\r\n * or replaced, then this dependent field will no longer function.\r\n */\r\nexport class FieldDependentDropdown extends Blockly.FieldDropdown {\r\n  /**\r\n   * Contains data used by this dropdown field's menu generator.\r\n   *\r\n   * The menu generator cannot refer directly to this FieldDependentDropdown\r\n   * instance, because it must be created before calling the super constructor\r\n   * when the \"this\" reference is not yet valid. This helper structure is used\r\n   * instead.\r\n   *\r\n   * This is public so that the DependentDropdownOptionsChangeJson event can\r\n   * update it while undoing/redoing.\r\n   */\r\n  dependencyData: DependencyData;\r\n\r\n  /** The name of the field that determines this field's options. */\r\n  private parentName: string;\r\n\r\n  /**\r\n   * The mapping from the parent field's value to this field's intended\r\n   * available options. The keys are strings representing the parent's possible\r\n   * values, and the values are the corresponding options to use in this child\r\n   * field.\r\n   */\r\n  private optionMapping: ChildOptionMapping;\r\n\r\n  /**\r\n   * An optional fallback set of options to use if the parent field's value does\r\n   * not match any of the keys in optionMapping.\r\n   */\r\n  private defaultOptions?: Blockly.MenuOption[];\r\n\r\n  /**\r\n   * Constructs a new FieldDependentDropdown.\r\n   *\r\n   * @param parentName The name of the parent field whose value determines this\r\n   *    field's available options.\r\n   * @param optionMapping A mapping from the possible values of the parent field\r\n   *    to the corresponding available options of this child field. The keys are\r\n   *    the possible values of the parent field, and the values are the\r\n   *    corresponding arrays of options for this child field.\r\n   * @param defaultOptions An optional fallback set of options to use if the\r\n   *    parent field's value does not match any of the keys in optionMapping.\r\n   * @param validator An optional function that is called to validate changes to\r\n   *    this field's value.\r\n   * @param config An optional map of general options used to configure the\r\n   *    field, such as a tooltip.\r\n   */\r\n  constructor(\r\n    parentName: string,\r\n    optionMapping: ChildOptionMapping,\r\n    defaultOptions?: Blockly.MenuOption[],\r\n    validator?: Blockly.FieldValidator,\r\n    config?: FieldConfig,\r\n  ) {\r\n    // A menu generator needs to be passed to the super constructor, but it\r\n    // needs to be able to reference data that hasn't been populated yet. We're\r\n    // not allowed to refer to \"this\" in this constructor before calling\r\n    // \"super\", so let's make separate structure to hold data relevant to the\r\n    // menu generator and populate that later.\r\n    const dependencyData: DependencyData = {};\r\n\r\n    // A menu option generator function for this child field that reads the\r\n    // derived options in the dependency data if available.\r\n    const menuGenerator: Blockly.MenuGeneratorFunction = () => {\r\n      // If derivedOptions has been initialized, use that.\r\n      if (dependencyData.derivedOptions) {\r\n        return dependencyData.derivedOptions;\r\n      }\r\n\r\n      // Fall back on the options corresponding to the parent field's current\r\n      // value (which is fine when initializing but may be out of date when\r\n      // making changes since the parent field's validator function triggers\r\n      // this function before the parent field's value is updated).\r\n\r\n      // If the parent field exists, and its value is a key in the provided\r\n      // option mapping, use the corresponding options.\r\n      if (dependencyData.parentField) {\r\n        const value = dependencyData.parentField.getValue();\r\n        if (value) {\r\n          const options = optionMapping[value];\r\n          if (options) {\r\n            return options;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (defaultOptions) {\r\n        return defaultOptions;\r\n      }\r\n\r\n      // Fall back on basic default options.\r\n      return [['', '']];\r\n    };\r\n\r\n    super(menuGenerator, validator, config);\r\n    this.parentName = parentName;\r\n    this.optionMapping = optionMapping;\r\n    this.defaultOptions = defaultOptions;\r\n    this.dependencyData = dependencyData;\r\n  }\r\n\r\n  /**\r\n   * Constructs a FieldDependentDropdown from a JSON arg object.\r\n   *\r\n   * @param options A JSON object providing \"parentName\" and \"optionMapping\".\r\n   * @returns The new field instance.\r\n   */\r\n  static fromJson(\r\n    options: FieldDependentDropdownFromJsonConfig,\r\n  ): FieldDependentDropdown {\r\n    return new FieldDependentDropdown(\r\n      options['parentName'],\r\n      options['optionMapping'],\r\n      options['defaultOptions'],\r\n      undefined,\r\n      options,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Attach this field to a block.\r\n   *\r\n   * @param block The block containing this field.\r\n   */\r\n  setSourceBlock(block: Blockly.Block) {\r\n    super.setSourceBlock(block);\r\n\r\n    const parentField: Blockly.Field<string> | null = block.getField(\r\n      this.parentName,\r\n    );\r\n\r\n    if (!parentField) {\r\n      throw new Error(\r\n        'Could not find a parent field with the name ' +\r\n          this.parentName +\r\n          ' for the dependent dropdown.',\r\n      );\r\n    }\r\n\r\n    this.dependencyData.parentField = parentField;\r\n\r\n    const oldValidator = parentField.getValidator();\r\n\r\n    // A validator function for the parent field that has the side effect of\r\n    // updating the options of this child dropdown field based on the new value\r\n    // of the parent field whenever it changes. The validator function is a good\r\n    // place to do this because it is called immediately while deserializing\r\n    // workspaces before the following fields are deserialized, so when the\r\n    // child value is deserialized the appropriate options will already be\r\n    // available. If the parent already had a validator function, it will be\r\n    // composed with this one and the new value returned from it will be the\r\n    // basis for determining the new available options.\r\n    parentField.setValidator((newValue) => {\r\n      if (oldValidator) {\r\n        const validatedValue = oldValidator(newValue);\r\n        // If a validator returns null, that means the new value is invalid and\r\n        // the change should be canceled.\r\n        if (validatedValue === null) {\r\n          return null;\r\n        }\r\n        // If a validator returns undefined, that means no change. Otherwise,\r\n        // use the returned value as the new value.\r\n        if (validatedValue !== undefined) {\r\n          newValue = validatedValue;\r\n        }\r\n      }\r\n      this.updateOptionsBasedOnNewValue(newValue);\r\n      return newValue;\r\n    });\r\n    this.updateOptionsBasedOnNewValue(parentField.getValue() ?? undefined);\r\n  }\r\n\r\n  /**\r\n   * Updates the options of this child dropdown field based on the new value of\r\n   * the parent field.\r\n   *\r\n   * @param newValue The newly assigned value.\r\n   */\r\n  private updateOptionsBasedOnNewValue(newValue: string | undefined): void {\r\n    if (newValue == undefined) {\r\n      return;\r\n    }\r\n\r\n    const block = this.getSourceBlock();\r\n    if (!block) {\r\n      throw new Error(\r\n        'Could not validate a field that is not attached to a block: ' +\r\n          this.name,\r\n      );\r\n    }\r\n\r\n    const oldChildValue = this.getValue();\r\n    const oldChildOptions = this.getOptions(false);\r\n    let newChildOptions = this.optionMapping[newValue];\r\n    if (!newChildOptions) {\r\n      if (this.defaultOptions) {\r\n        newChildOptions = this.defaultOptions;\r\n      } else {\r\n        console.warn(\r\n          'Could not find child options for the parent value: ' + newValue,\r\n        );\r\n        return;\r\n      }\r\n    }\r\n\r\n    // If the child field's value is still available in the new options, keep\r\n    // it, otherwise change the field's value to the first available option.\r\n    const newOptionsIncludeOldValue =\r\n      newChildOptions.find((option) => option[1] == oldChildValue) != undefined;\r\n    const newChildValue = newOptionsIncludeOldValue\r\n      ? oldChildValue\r\n      : newChildOptions[0][1];\r\n\r\n    // Record the options so that the option generator can access them.\r\n    this.dependencyData.derivedOptions = newChildOptions;\r\n\r\n    // Re-run the option generator to update the options on the dropdown.\r\n    this.getOptions(false);\r\n\r\n    // Update this child field's value without broadcasting the normal change\r\n    // event. The normal value change event can't be properly undone, because\r\n    // the old value may not be one of the currently valid options, so a custom\r\n    // change event will be broadcast instead that handles swapping the options\r\n    // and the value at the same time.\r\n    Blockly.Events.disable();\r\n    this.setValue(newChildValue);\r\n    Blockly.Events.enable();\r\n\r\n    if (Blockly.Events.getRecordUndo()) {\r\n      if (!Blockly.Events.getGroup()) {\r\n        // Start a change group before the change event. The change event for\r\n        // the parent field value will be created after this function returns\r\n        // and will be part of the same group.\r\n        Blockly.Events.setGroup(true);\r\n        // Clear the change group later, after all related events have been\r\n        // broadcast, but before the user performs any more actions.\r\n        setTimeout(() => Blockly.Events.setGroup(false));\r\n      }\r\n\r\n      // Record that the child field's options and value have changed.\r\n      Blockly.Events.fire(\r\n        new DependentDropdownOptionsChange(\r\n          block,\r\n          this.name,\r\n          oldChildValue ?? undefined,\r\n          newChildValue ?? undefined,\r\n          oldChildOptions,\r\n          newChildOptions,\r\n        ),\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nBlockly.fieldRegistry.register(\r\n  'field_dependent_dropdown',\r\n  FieldDependentDropdown,\r\n);\r\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","arraysAreEquivalent","b","length","every","aElement","index","bElement","Array","isArray","DependentDropdownOptionsChange","BlockBase","constructor","block","name","oldValue","newValue","oldOptions","newOptions","super","type","EVENT_TYPE","toJson","json","Error","fromJson","workspace","event","newEvent","isNull","valuesAreEqual","optionsAreEquivalent","run","forward","blockId","console","warn","getEventWorkspace_","getBlockById","dropdown","getField","options","dependencyData","derivedOptions","getOptions","setValue","register","Type","EVENT","FieldDependentDropdown","parentName","optionMapping","defaultOptions","validator","config","parentField","getValue","setSourceBlock","oldValidator","getValidator","setValidator","validatedValue","updateOptionsBasedOnNewValue","getSourceBlock","oldChildValue","oldChildOptions","newChildOptions","newChildValue","find","option","disable","enable","getRecordUndo","getGroup","setGroup","setTimeout","fire"],"sourceRoot":""}